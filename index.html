<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/default.min.css">
    <title>Technical Documentation Page</title>
</head>
<body>

    <nav id="navbar">
        <header>Node js</header>
       
        <a class="nav-link" href="#s1">Introduction to Node.js</a>
        <a class="nav-link" href="#s2">Installation</a>
        <a class="nav-link" href="#s3">Understanding JavaScript Promises</a>
        <a class="nav-link" href="#s4">The Node.js Event emitter</a>
        <a class="nav-link" href="#s5">Node.js Streams</a>
        
      </nav>
      
      <main id="main-doc">
        <section id="s1" class="main-section">
          <header>Installing</header>
          <div>
            <p>Node.js is an open-source and cross-platform JavaScript runtime environment. It is a popular tool for almost any kind of project!</p>
            <p>Node.js runs the V8 JavaScript engine, the core of Google Chrome, outside of the browser. This allows Node.js to be very performant.</p>
            <p>A Node.js app runs in a single process, without creating a new thread for every request. Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.</p>
            <p>When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.</p>  
            <h2>Node.js Frameworks and Tools</h2>

            <P>Node.js is a low-level platform. In order to make things easy and exciting for developers, thousands of libraries were built upon Node.js by the community.</P>
            <P>Many of those established over time as popular options. Here is a non-comprehensive list of the ones worth learning:</P>
            <ul>
                <li><b>Express</b>: It provides one of the most simple yet powerful ways to create a web server. Its minimalist approach, unopinionated, focused on the core features of a server, is key to its success.</li>
                <li><b>Fastify</b>: A web framework highly focused on providing the best developer experience with the least overhead and a powerful plugin architecture. Fastify is one of the fastest Node.js web frameworks.</li>
                <li><b>AdonisJs</b>: A full-stack framework highly focused on developer ergonomics, stability, and confidence. Adonis is one of the fastest Node.js web frameworks.</li>
                <li><b>Gatsby</b>: A React-based, GraphQL powered, static site generator with a very rich ecosystem of plugins and starters.</li>
                <li><b>hapi</b>: A rich framework for building applications and services that enables developers to focus on writing reusable application logic instead of spending time building infrastructure.</li>
            </ul>
        </section>
        <hr>
        <section id="s2" class="main-section">
          <header>Installation</header>
          <div>
            <h2>Windows</h2>
            <p>Download the <a href="https://nodejs.org/en/#home-downloadhead">Windows Installer</a> directly from the nodejs.org web site.</p>
            <h2>Mac</h2>
            <p>On macOS, Homebrew is the de-facto standard, and - once installed - allows you to install Node.js very easily, by running this command in the CLI:</p>
            <pre>
                <code class="nohighlight">brew install node</code>
            </pre>
            <h2>Linux: Debian and Ubuntu based Linux distributions</h2>
            <p>On macOS, Homebrew is the de-facto standard, and - once installed - allows you to install Node.js very easily, by running this command in the CLI:</p>
            <p>Using Ubuntu</p>
            <pre>
                <code class="nohighlight">curl -fsSL https://deb.nodesource.com/setup_current.x | sudo -E bash -
sudo apt-get install -y nodejs</code>
            </pre>
            <p>Using Debian, as root</p>
            <pre>
                <code class="nohighlight">curl -fsSL https://deb.nodesource.com/setup_current.x | bash -
apt-get install -y nodejs</code>
            </pre>
          </div>
        </section>
        <hr>
        <section id="s3" class="main-section">
          <header>Understanding JavaScript Promises</header>
          <div>
            <p>A promise is commonly defined as a proxy for a value that will eventually become available.
            <p>Promises are one way to deal with asynchronous code, without getting stuck in callback hell.</p>
            <p>Promises have been part of the language for years (standardized and introduced in ES2015), and have recently become more integrated, with async and await in ES2017.</p>
            <p>Async functions use promises behind the scenes, so understanding how promises work is fundamental to understanding how async and await work.</p></p>
            <h2>Creating a promise</h2>
            <p>The Promise API exposes a Promise constructor, which you initialize using new Promise():</p>
            <pre>
              <code class="nohighlight">let done = true

const isItDoneYet = new Promise((resolve, reject) => {
    if (done) {
    const workDone = 'Here is the thing I built'
    resolve(workDone)
    } else {
    const why = 'Still working on something else'
    reject(why)
    }
})</code>
            </pre>
            <h2>Consuming a promise</h2>
            <p>In the last section, we introduced how a promise is created.
            <p>Now let's see how the promise can be consumed or used.</p>
            <pre>
              <code class="nohighlight">const isItDoneYet = new Promise(/* ... as above ... */)
//...

const checkIfItsDone = () => {
    isItDoneYet
    .then(ok => {
        console.log(ok)
    })
    .catch(err => {
        console.error(err)
    })
}</code>
            </pre>
            <p>Running checkIfItsDone() will specify functions to execute when the isItDoneYet promise resolves (in the then call) or rejects (in the catch call).</p>
            
        </div>
    </section>
    <hr>
    <section id="s4" class="main-section">
        <header>
            The Node.js Event emitter
        </header>
        <div>
            <p>If you worked with JavaScript in the browser, you know how much of the interaction of the user is handled through events: mouse clicks, keyboard button presses, reacting to mouse movements, and so on.
                <p>On the backend side, Node.js offers us the option to build a similar system using the events module.</p>
                <p>This module, in particular, offers the EventEmitter class, which we'll use to handle our events.    </p>
                <p>You initialize that using</p>
                <pre>
                  <code class="nohighlight">const EventEmitter = require('events')
const eventEmitter = new EventEmitter()</code>
                </pre>
                <p>This object exposes, among many others, the on and emit methods.</p>
                <ul>
                    <li><b>emit</b> is used to trigger an event</li>
                    <li><b>on</b>is used to add a callback function that's going to be executed when the event is triggered</li>
                </ul>
                <p>For example, let's create a start event, and as a matter of providing a sample, we react to that by just logging to the console:</p>
                <pre>
                  <code class="nohighlight">eventEmitter.on('start', () => {
console.log('started')
})</code>
                </pre>
                <p>When we run</p>
                <pre>
                  <code class="nohighlight">eventEmitter.emit('start')</code>
                </pre>
                <p>the event handler function is triggered, and we get the console log.</p>
                <p>You can pass arguments to the event handler by passing them as additional arguments to emit():</p>
                <pre>
                    <code class="nohighlight">eventEmitter.on('start', number => {
                        console.log(`started ${number}`)
                    })
                    
                    eventEmitter.emit('start', 23)</code>
                </pre>
                <p>The EventEmitter object also exposes several other methods to interact with events, like</p>
                <ul>
                    <li><b>once()</b>: add a one-time listener</li>
                    <li><b>removeListener() / off()</b>: remove an event listener from an event</li>
                    <li><b>removeAllListeners()</b>: remove all listeners for an event</li>
                </ul>
                <p>You can read all their details on the events module page at <a href="https://nodejs.org/api/events.html">https://nodejs.org/api/events.html</a></p>
                
            </div>
        </section>
        <hr>
        <section id="s5" class="main-section">
            <header>
                Node.js Streams
            </header>
            <div>
                <p>Streams are one of the fundamental concepts that power Node.js applications.</p>
                <p>They are a way to handle reading/writing files, network communications, or any kind of end-to-end information exchange in an efficient way.</p>
                <p>Streams are not a concept unique to Node.js. They were introduced in the Unix operating system decades ago, and programs can interact with each other passing streams through the pipe operator (|).</p>
                <p>For example, in the traditional way, when you tell the program to read a file, the file is read into memory, from start to finish, and then you process it.</p>
                <p>Using streams you read it piece by piece, processing its content without keeping it all in memory.</p>   
                <h2>An example of a stream</h2>
                <p>A typical example is reading files from a disk.</p>
                <p>Using the Node.js fs module, you can read a file, and serve it over HTTP when a new connection is established to your HTTP server:</p>
                <pre>
                  <code class="nohighlight">const http = require('http')
const fs = require('fs')

const server = http.createServer(function(req, res) {
    fs.readFile(__dirname + '/data.txt', (err, data) => {
    res.end(data)
    })
})
server.listen(3000)</code>
                </pre>
                <p>readFile() reads the full contents of the file, and invokes the callback function when it's done.</p>
                <p>res.end(data) in the callback will return the file contents to the HTTP client.</p>
                <h2>pipe()</h2>
                <p>The above example uses the line stream.pipe(res): the pipe() method is called on the file stream.</p>
                <p>What does this code do? It takes the source, and pipes it into a destination.</p>
                <p>You call it on the source stream, so in this case, the file stream is piped to the HTTP response.</p>
                <p>The return value of the pipe() method is the destination stream, which is a very convenient thing that lets us chain multiple pipe() calls, like this:</p>
                <pre>
                  <code class="nohighlight">src.pipe(dest1).pipe(dest2)</code>
                </pre>
                <h2>Streams-powered Node.js APIs</h2>
                <p>Due to their advantages, many Node.js core modules provide native stream handling capabilities, most notably:</p>
                <ul>
                   <li><b>process.stdin</b> returns a stream connected to stdin</li>
                   <li><b>process.stdout</b> returns a stream connected to stdout</li>
                   <li><b>process.stderr</b> returns a stream connected to stderr</li>
                   <li><b>fs.createReadStream()</b> creates a readable stream to a file</li>
                   <li><b>fs.createWriteStream()</b> creates a writable stream to a file</li>
                   <li><b>net.connect()</b> initiates a stream-based connection</li>
                   <li><b>http.request()</b> returns an instance of the http.ClientRequest class, which is a writable stream</li>
                   <li><b>zlib.createGzip()</b> compress data using gzip (a compression algorithm) into a stream</li>
                   <li><b>zlib.createGunzip()</b> decompress a gzip stream</li>
                   <li><b>zlib.createDeflate()</b> compress data using deflate (a compression algorithm) into a stream</li>
                   <li><b>zlib.createInflate()</b> decompress a deflate stream</li>
                </ul>
                
            </div>
        </section>
    </main>
</body>
<script src="/index.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
</html>